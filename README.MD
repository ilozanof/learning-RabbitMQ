# learning-RabbitMQ
This project is a *Proof Of Concept* of *RabbitMQ*, includes guidelines 
about installation/configuration and some basic examples or common design 
patterns in an *Event Driver Architecture*.

## Installation
All the tests in this project assumes that *RabbitMQ* is installed and running
in the same machine. For guidelines about the installation:

[Installing in MAC using *HomeBrew*](https://www.rabbitmq.com/install-homebrew.html)

*and more links for other OS's can be found [here](https://www.rabbitmq.com/download.html)*
 
After the installation, the *RabbitMQ* scripts will be stored in the */usr/local/sbin* folder, so adding 
that folder to the **PATH** system variabel might be a good idea.

Now we can enable the **Management Plugin** following the guidelines 
explained here: [Management Plugin](https://www.rabbitmq.com/management.html)
 
 To enable the *Management Console* (before running the server), run this command:
 
 ``rabbitmq-plugins enable rabbitmq_management``
 
 ## Start and stop the Server
 
 After enabling the *Management Console* we can run the server now:
 
 ``rabbitmq-server``
 
. Now we can access the web console with a web browser:
  * url: **http://localhost:15672**
  * user: **guest**
  * password: **guest**
 
 According to the Official documentation, To stop the server run this command:
 
 ``rabbitmq-server stop``
 
 but it sometimes triggers the error "ERROR: node with name 'rabbit' already 
 running on 'localhost'". If that's the case, try running this command instead:
 
 ``rabbitmqctl stop``
 
 
  ## HelloWord example
  
  > * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/helloWorld*
  > * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/helloWorld*
  
  This example is based on the example described in 
  [Java Tutorial - Hello World](https://www.rabbitmq.com/tutorials/tutorial-one-java.html).
  
  instead of just using *main* blocks of code, here we are putting the logic in separate classes,
  *Sender.java* and *Receiver.java*, and jUnit tests. 
  
  The "Sender" sends a text message to the QUEUE, and the "Receiver" consumes it.
  
## Work Queues

  > * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/workQueues*
  > * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/workQueues*
  
  This example is based on the example from [Java Tutorial - Work Queues](https://www.rabbitmq.com/tutorials/tutorial-two-java.html)
  , but with many changes.
  
   * We are reusing the same *Sender* implemented for the previous example.
   * A new *Worker" has been developed, which is an evolved version of the *Receiver* class from the preivous example. 
   In this case, the *Worker* can be parametrized to:
        * perform auto acknowledge or not
        * keep track of the numbner opf tasks done
        * simulate an error throwing an Exception, based on a value in the Constructor.
        
  The Test in *src/test/main/com/ilozanof/learning/rabbitMQ/workQueues" checks different scenearios, like:
    * round-robin task assignment performed by *RabbgitMQ*
    * Reassigned of tasks when some of the consumers fails.
    
## Publish/Subscribe
> * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/publishSubscribe*
> * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/publishSubscribe*
  
This example is based on the example from Java [Tutorial - Publish/Subscribe](https://www.rabbitmq.com/tutorials/tutorial-three-java.html) , but with some changes:
 * The consumers are now declared in independent classes, as opposed to using anonymous classes.
 * There is one sender, *LogSender*, and 2 different consumer (although they do the same thing), *LogConsumer1* and 
 *LogConsumer2*. The *LogReceiver* class (is that a good name?) takes care of creating one specifif queue for each 
 consumer, this queue is a disposable one, so the name is generated by the server and each *Logconsumer* is "assigned"
  to each of these queues.

## Topic
> * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/topic*
> * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/topic*

This example shows how to configur an exchange as a *Topic*, which is pretty much the same as in the preivous examples, the only thing that changes is that
the routing key can include some patterns, so we can control that way the Queue
the message is going to.

In this example: 
  
  * the *SignalSender* sends "signals" to different Systems/applications. these applications are referred to as "System1.dev", or "system2.subsysrtemA.test", for example.
  
  * the *SignalReceiver* creates the different queues ("test", "dev", "prod") and the binding between them and the Exchange.
  
  * the *SignalConsumer* is a very simple Cnsumer which only logs the message that comes to it. The Consumer has an *id* wich relates to the system it's 
  consuming signals from.


## NOTES
This chapter includes some notes about some aspects of RabbitMQ that might be interesting to know and remember:

* **The order of Senders/Workers is important:**
    If you send the meesages to the queue first, and then register the consumer, only the first consumer is used. 
    But if you register first the consumers and then you send messages to the Queue (which seems to be the right
    order to follow), then the loaded is balanced between the consumers properly.
  