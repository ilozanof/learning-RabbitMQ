# learning-RabbitMQ
This project is a *Proof Of Concept* of *RabbitMQ*, includes guidelines 
about installation/configuration and some basic examples or common design 
patterns in an *Event Driver Architecture*.

## Installation
All the tests in this project assumes that *RabbitMQ* is installed and running
in the same machine. For guidelines about the installation:

[Installing in MAC using *HomeBrew*](https://www.rabbitmq.com/install-homebrew.html)

*and more links for other OS's can be found [here](https://www.rabbitmq.com/download.html)*
 
After the installation, the *RabbitMQ* scripts will be stored in the */usr/local/sbin* folder, so adding 
that folder to the **PATH** system variabel might be a good idea.

Now we can enable the **Management Plugin** following the guidelines 
explained here: [Management Plugin](https://www.rabbitmq.com/management.html)
 
 To enable the *Management Console* (before running the server), run this command:
 
 ``rabbitmq-plugins enable rabbitmq_management``
 
 ## Start and stop te Server
 
 After enabling the *Management Console* we can run the server now:
 
 ``rabbitmq-server``
 
. Now we can access the web console with a web browser:
  * url: **http://localhost:15672**
  * user: **guest**
  * password: **guest**
 
 According to the Official documentation, To stop the server run this command:
 
 ``rabbitmq-server stop``
 
 but it sometimes triggers the error "ERROR: node with name 'rabbit' already 
 running on 'localhost'". If that's the case, try running this command instead:
 
 ``rabbitmqctl stop``
 
 
  ## HelloWord example
  
  This example is based on the example described in 
  [Java Tutorial - Hello World](https://www.rabbitmq.com/tutorials/tutorial-one-java.html).
  
  instead of just using *main* blocks of code, here we are putting the logic in separate classes,
  *Sender.java* and *Receiver.java*, and jUnit tests. 
  
  The "Sender" sends a text message to the QUEUE, and the "Receiver" consumes it.
  
  ## Work Queues
  This example is based on the example from [Java Yutorial - Work Queues](https://www.rabbitmq.com/tutorials/tutorial-two-java.html)
  , but with many changes.
  
   * We are reusing the same *Sender* implemented for the previous example.
   * A new *Worker" has been developed, which is an evolved version of the *Receiver* class from the preivous example. 
   In this case, the *Worker* can be parametrized to:
        * perform auto acknowledge or not
        * keep track of the numbner opf tasks done
        * simulate an error throwing an Exception, based on a value in the Constructor.
        
  The Test in *src/test/main/com/ilozanof/learning/rabbitMQ/workQueues" checks different scenearios, like:
    * round-robin task assignment performed by *RabbgitMQ*
    * Reassigned of tasks when some of the consumers fails.
    
## Publish/Subscribe
This example os based on [this one](https://www.rabbitmq.com/tutorials/tutorial-three-java.html), but with some changes in the
classes involved, like:
 * The consumers are now declared in independent classes, as opposed to using anonymous classes.
 * There is one sender, *LogSender*, and 2 different consumer (although they do the same thing), *LogConsumer1* and 
 *LogConsumer2*. The *LogReceiver* class (is that a good name?) takes care of creating one specifif queue for each 
 consumer, this queue is a disposable one, so the name is generated by the server and each *Logconsumer* is "assigned"
  to each of these queues.

## NOTES
This chapter includes some notes about some aspects of RabbitMQ that might be interesting to know and remember:

* **The order of Senders/Workers is important:**
    If you send the meesages to the queue first, and then register the consumer, only the first consumer is used. 
    But if you register first the consumers and then you send messages to the Queue (which seems to be the right
    order to follow), then the loaded is balanced between the consumers properly.
  