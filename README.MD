# learning-RabbitMQ
This project is a *Proof Of Concept* of *RabbitMQ*, includes guidelines 
about installation/configuration and some basic examples or common design 
patterns in an *Event Driver Architecture*.

## Installation
All the tests in this project assumes that *RabbitMQ* is installed and running
in the same machine. For guidelines about the installation:

[Installing in MAC using *HomeBrew*](https://www.rabbitmq.com/install-homebrew.html)

*and more links for other OS's can be found [here](https://www.rabbitmq.com/download.html)*
 
After the installation, the *RabbitMQ* scripts will be stored in the */usr/local/sbin* folder, so adding 
that folder to the **PATH** system variabel might be a good idea.

Now we can enable the **Management Plugin** following the guidelines 
explained here: [Management Plugin](https://www.rabbitmq.com/management.html)
 
 To enable the *Management Console* (before running the server), run this command:
 
 ``rabbitmq-plugins enable rabbitmq_management``
 
 ## Start and stop the Server
 
 After enabling the *Management Console* we can run the server now:
 
 ``rabbitmq-server``
 
. Now we can access the web console with a web browser:
  * url: **http://localhost:15672**
  * user: **guest**
  * password: **guest**
 
 According to the Official documentation, To stop the server run this command:
 
 ``rabbitmq-server stop``
 
 but it sometimes triggers the error "ERROR: node with name 'rabbit' already 
 running on 'localhost'". If that's the case, try running this command instead:
 
 ``rabbitmqctl stop``
 
 
  ## HelloWord example
  
  > * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/helloWorld*
  > * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/helloWorld*
  
  This example is based on the example described in 
  [Java Tutorial - Hello World](https://www.rabbitmq.com/tutorials/tutorial-one-java.html).
  
  instead of just using *main* blocks of code, here we are putting the logic in separate classes,
  *Sender.java* and *Receiver.java*, and jUnit tests. 
  
  The "Sender" sends a text message to the QUEUE, and the "Receiver" consumes it.
  
## Work Queues

  > * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/workQueues*
  > * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/workQueues*
  
  This example is based on the example from [Java Tutorial - Work Queues](https://www.rabbitmq.com/tutorials/tutorial-two-java.html)
  , but with many changes.
  
   * We are reusing the same *Sender* implemented for the previous example.
   * A new *Worker" has been developed, which is an evolved version of the *Receiver* class from the preivous example. 
   In this case, the *Worker* can be parametrized to:
        * perform auto acknowledge or not
        * keep track of the numbner opf tasks done
        * simulate an error throwing an Exception, based on a value in the Constructor.
        
  The Test in *src/test/main/com/ilozanof/learning/rabbitMQ/workQueues" checks different scenearios, like:
    * round-robin task assignment performed by *RabbgitMQ*
    * Reassigned of tasks when some of the consumers fails.
    
## Publish/Subscribe
> * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/publishSubscribe*
> * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/publishSubscribe*
  
This example is based on the example from Java [Tutorial - Publish/Subscribe](https://www.rabbitmq.com/tutorials/tutorial-three-java.html) , but with some changes:
 * The consumers are now declared in independent classes, as opposed to using anonymous classes.
 * There is one sender, *LogSender*, and 2 different consumer (although they do the same thing), *LogConsumer1* and 
 *LogConsumer2*. The *LogReceiver* class (is that a good name?) takes care of creating one specifif queue for each 
 consumer, this queue is a disposable one, so the name is generated by the server and each *Logconsumer* is "assigned"
  to each of these queues.

## About the *Topic* and *Headers* examples
Both *Topic* and *Headers* examples represent the same scenario:
* We have a Signal broadcast system, wo a *Sender* can send signals to different *systems* (like applications), and 
each system can "live" i a different *environment* (like "test", "dev", or "prod").
* We have one *queue* for each *environment*, and the name of the *queue* is the name of the 
enviroment, so we have the queues *test*, *dev* and *prod*.
* For each queue, we have a single *Consumer* getting signal out of it. So we have
3 Consumers in total.

The *Topic* and *Headers* examples further down test how to send signal to those systems, and how those 
signal are redirected to the right queue. The difference is in *HOW* to redirect the 
signals, by using the *routingKey* and patterns (*Topics* example), or by using *Headers* (*Headers* example).

Due to the fact that the functionality in both examples is similar, they both share some common classes/inrterfaces, defined in 
the *common* package.


### Topic example
> * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/topic*
> * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/topic*

### Headers example
> * main classes: *src/main/java/com/ilozanof/learning/rabbitMQ/headers*
> * test classes: *src/test/java/com/ilozanof/learning/rabbitMQ/headers*



## NOTES
This chapter includes some notes about some aspects of RabbitMQ that might be interesting to know and remember:

* **The order of Senders/Workers is important:**
    If you send the meesages to the queue first, and then register the consumer, only the first consumer is used. 
    But if you register first the consumers and then you send messages to the Queue (which seems to be the right
    order to follow), then the loaded is balanced between the consumers properly.
  